# Fix compilation on architectures without MMX and libav 0.8.
# Closes: #658376
# Hopefuly it will also fix a bug with libav 0.8 where your video gets inverted colors.
# Closes: #657871

diff -Naur mlt-0.7.6+git20120204.orig/src/modules/avformat/consumer_avformat.c mlt-0.7.6+git20120204/src/modules/avformat/consumer_avformat.c
--- mlt-0.7.6+git20120204.orig/src/modules/avformat/consumer_avformat.c	2012-02-04 14:14:54.000000000 +0100
+++ mlt-0.7.6+git20120204/src/modules/avformat/consumer_avformat.c	2012-02-05 13:22:39.879438830 +0100
@@ -394,7 +394,7 @@
 	for ( i = 0; i < count; i++ )
 	{
 		const char *opt_name = mlt_properties_get_name( properties, i );
-#if LIBAVUTIL_VERSION_INT > ((51<<16)+(7<<8)+0)
+#if LIBAVUTIL_VERSION_INT >= ((51<<16)+(10<<8)+0)
 		const AVOption *opt = av_opt_find( obj, opt_name, NULL, flags, flags );
 #else
 		const AVOption *opt = av_find_opt( obj, opt_name, NULL, flags, flags );
@@ -404,7 +404,7 @@
 		if ( !opt && (
 			( opt_name[0] == 'v' && ( flags & AV_OPT_FLAG_VIDEO_PARAM ) ) ||
 			( opt_name[0] == 'a' && ( flags & AV_OPT_FLAG_AUDIO_PARAM ) ) ) )
-#if LIBAVUTIL_VERSION_INT > ((51<<16)+(7<<8)+0)
+#if LIBAVUTIL_VERSION_INT >= ((51<<16)+(10<<8)+0)
 			opt = av_opt_find( obj, ++opt_name, NULL, flags, flags );
 #else
 			opt = av_find_opt( obj, ++opt_name, NULL, flags, flags );
@@ -1501,15 +1501,16 @@
 					fifo = sample_fifo_init( frequency, channels );
 					mlt_properties_set_data( properties, "sample_fifo", fifo, 0, ( mlt_destructor )sample_fifo_close, NULL );
 				}
-
-				// Silence if not normal forward speed
-				if ( mlt_properties_get_double( frame_properties, "_speed" ) != 1.0 )
-					memset( pcm, 0, samples * channels * sample_bytes );
-
-				// Append the samples
-				sample_fifo_append( fifo, pcm, samples * channels * sample_bytes );
-				total_time += ( samples * 1000000 ) / frequency;
-
+				if ( pcm )
+				{
+					// Silence if not normal forward speed
+					if ( mlt_properties_get_double( frame_properties, "_speed" ) != 1.0 )
+						memset( pcm, 0, samples * channels * sample_bytes );
+
+					// Append the samples
+					sample_fifo_append( fifo, pcm, samples * channels * sample_bytes );
+					total_time += ( samples * 1000000 ) / frequency;
+				}
 				if ( !video_st )
 					mlt_events_fire( properties, "consumer-frame-show", frame, NULL );
 			}
@@ -1700,7 +1701,7 @@
 
 						// Do the colour space conversion
 #ifdef SWSCALE
-						int flags = SWS_BILINEAR;
+						int flags = SWS_BICUBIC;
 #ifdef USE_MMX
 						flags |= SWS_CPU_CAPS_MMX;
 #endif
diff -Naur mlt-0.7.6+git20120204.orig/src/modules/avformat/filter_avcolour_space.c mlt-0.7.6+git20120204/src/modules/avformat/filter_avcolour_space.c
--- mlt-0.7.6+git20120204.orig/src/modules/avformat/filter_avcolour_space.c	2011-12-13 19:28:26.000000000 +0100
+++ mlt-0.7.6+git20120204/src/modules/avformat/filter_avcolour_space.c	2012-02-05 13:22:39.879438830 +0100
@@ -117,7 +117,7 @@
 	AVPicture input;
 	AVPicture output;
 #ifdef SWSCALE
-	int flags = SWS_BILINEAR | SWS_ACCURATE_RND;
+	int flags = SWS_BICUBIC | SWS_ACCURATE_RND;
 
 	if ( out_fmt == PIX_FMT_YUYV422 )
 		flags |= SWS_FULL_CHR_H_INP;
diff -Naur mlt-0.7.6+git20120204.orig/src/modules/avformat/filter_avdeinterlace.c mlt-0.7.6+git20120204/src/modules/avformat/filter_avdeinterlace.c
--- mlt-0.7.6+git20120204.orig/src/modules/avformat/filter_avdeinterlace.c	2011-03-15 18:55:45.000000000 +0100
+++ mlt-0.7.6+git20120204/src/modules/avformat/filter_avdeinterlace.c	2012-02-05 13:22:39.879438830 +0100
@@ -31,7 +31,7 @@
 #include "mmx.h"
 #else
 #define MAX_NEG_CROP 1024
-extern uint8_t ff_cropTbl[256 + 2 * MAX_NEG_CROP];
+static uint8_t ff_cropTbl[256 + 2 * MAX_NEG_CROP] = {0,};
 #endif
 
 #ifdef USE_MMX
@@ -346,6 +346,17 @@
 
 mlt_filter filter_avdeinterlace_init( void *arg )
 {
+#ifndef USE_MMX
+	if ( ff_cropTbl[MAX_NEG_CROP + 1] == 0 )
+	{
+		int i;
+		for(i=0;i<256;i++) ff_cropTbl[i + MAX_NEG_CROP] = i;
+		for(i=0;i<MAX_NEG_CROP;i++) {
+			ff_cropTbl[i] = 0;
+			ff_cropTbl[i + MAX_NEG_CROP + 256] = 255;
+		}
+	}
+#endif
 	mlt_filter filter = mlt_filter_new( );
 	if ( filter != NULL )
 		filter->process = deinterlace_process;
diff -Naur mlt-0.7.6+git20120204.orig/src/modules/avformat/producer_avformat.c mlt-0.7.6+git20120204/src/modules/avformat/producer_avformat.c
--- mlt-0.7.6+git20120204.orig/src/modules/avformat/producer_avformat.c	2012-02-04 14:14:54.000000000 +0100
+++ mlt-0.7.6+git20120204/src/modules/avformat/producer_avformat.c	2012-02-05 13:22:39.883438678 +0100
@@ -1247,7 +1247,7 @@
 {
 #ifdef SWSCALE
 	int full_range = -1;
-	int flags = SWS_BILINEAR | SWS_ACCURATE_RND;
+	int flags = SWS_BICUBIC | SWS_ACCURATE_RND;
 
 #ifdef USE_MMX
 	flags |= SWS_CPU_CAPS_MMX;
@@ -1799,7 +1799,7 @@
 	for ( i = 0; i < count; i++ )
 	{
 		const char *opt_name = mlt_properties_get_name( properties, i );
-#if LIBAVUTIL_VERSION_INT > ((51<<16)+(7<<8)+0)
+#if LIBAVUTIL_VERSION_INT >= ((51<<16)+(10<<8)+0)
 		const AVOption *opt = av_opt_find( obj, opt_name, NULL, flags, flags );
 #else
 		const AVOption *opt = av_find_opt( obj, opt_name, NULL, flags, flags );
diff -Naur mlt-0.7.6+git20120204.orig/src/modules/core/producer_consumer.c mlt-0.7.6+git20120204/src/modules/core/producer_consumer.c
--- mlt-0.7.6+git20120204.orig/src/modules/core/producer_consumer.c	2012-02-04 14:14:54.000000000 +0100
+++ mlt-0.7.6+git20120204/src/modules/core/producer_consumer.c	2012-02-05 13:22:39.883438678 +0100
@@ -141,6 +141,7 @@
 
 		// Since we control the seeking, prevent it from seeking on its own
 		mlt_producer_set_speed( cx->producer, 0 );
+		cx->audio_position = -1;
 
 		// We will encapsulate a consumer
 		cx->consumer = mlt_consumer_new( cx->profile );
